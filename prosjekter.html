<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prosjekter – Chris Mulunda Mpinda</title>
    <link rel="stylesheet" href="css/style.css">
    <style>
        body { font-family: Arial, sans-serif; background:#f7f7f7; margin:0; }
        header { text-align:center; padding:2rem; background:white; border-bottom:1px solid #ddd; }
        nav ul { display:flex; justify-content:center; list-style:none; gap:2rem; padding:0; background:#222; margin:0; }
        nav a { color:white; text-decoration:none; font-weight:bold; padding:0.5rem 1rem; display:block; }
        nav a:hover { text-decoration:underline; }
        main { max-width:1000px; margin:0 auto; padding:2rem 1rem; }
        .tabs { display:flex; gap:1rem; margin-bottom:1rem; cursor:pointer; }
        .tab { padding:0.7rem 1.2rem; background:#ddd; border-radius:5px; }
        .tab.active { background:#222; color:white; }
        .tab-content { display:none; background:white; padding:1.5rem; border-radius:10px; box-shadow:0 1px 4px rgba(0,0,0,0.1); }
        .tab-content.active { display:block; }
        .section-box { margin-bottom:1.5rem; }
        
        /* Stil for kodevisning */
        pre { background: #f4f4f4; padding: 1rem; border-radius: 5px; overflow-x: auto; border: 1px solid #ddd; }
        code { font-family: Consolas, monospace; color: #333; }
    </style>
</head>
<body>

    <header>
        <h1>Prosjekter</h1>
        <p>Oversikt over LEGO, LEXO arm og dataarkitektur-prosjekter</p>
    </header>

    <nav>
        <ul>
            <li><a href="index.html">Hjem</a></li>
            <li><a href="prosjekter.html">Prosjekter</a></li>
            <li><a href="programmering.html">Programmeringsøvinger</a></li>
            <li><a href="annet.html">Annet</a></li>
        </ul>
    </nav>

    <main>
        <div class="tabs">
            <div class="tab active" data-tab="lego">LEGO</div>
            <div class="tab" data-tab="lexo">LEXO arm</div>
            <div class="tab" data-tab="data">Dataarkitektur</div>
        </div>

        <!-- LEGO TAB -->
        <div id="lego" class="tab-content active">
            <h2>LEGO Prosjekter</h2>
            <section class="section-box">
                <h2>Kode (LEGO / EV3)</h2>
                <p>Her vises koden direkte i nettleseren.</p>

                <article class="section-box">
                    <h3>Oppgave 1</h3>
                    <p><a href="EV3Tasks/code/oppgave1.py" download>Last ned filen</a></p>
                    <pre><code>
                      #!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import (Motor, TouchSensor, ColorSensor,
                                 InfraredSensor, UltrasonicSensor, GyroSensor)
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile

# Initialiser EV3-brikken (hovedenheten til roboten)
ev3 = EV3Brick()

# Initialiser motorene på port B og C (venstre og høyre hjul)
venstre_motor = Motor(Port.C)
hoyre_motor = Motor(Port.B)

# Initialiser sensorer
trykk_sensor = TouchSensor(Port.S1)  # Trykksensor for start/stopp
ultralyd_sensor = UltrasonicSensor(Port.S4)  # Ultralydsensor for hindringer

# Vis "Exercise 2" på LCD-skjermen
ev3.screen.print("Exercise 2")

# Vent på at trykksensor blir trykket for å starte
while not trykk_sensor.pressed():
    wait(10)

# Si "Exercise 2" og start gressklipping
ev3.speaker.say("Exercise 2")
wait(1000)

# Hovedløkke for gressklipping
kjoerer = True
while kjoerer:
    # Sjekk om trykksensor er trykket for å stoppe
    if trykk_sensor.pressed():
        kjoerer = False
        break
    
    # Sjekk avstand til hindringer (under 30 cm = hindring)
    if ultralyd_sensor.distance() < 300:  # 300 mm = 30 cm
        # Stopp motorene
        venstre_motor.stop()
        hoyre_motor.stop()
        wait(500)
        
        # Rygge litt
        venstre_motor.run_angle(400, -200, Stop.BRAKE, False)
        hoyre_motor.run_angle(400, -200, Stop.BRAKE, True)
        
        # Sving til høyre for å unngå hindringen
        venstre_motor.run_angle(400, 300, Stop.BRAKE, False)
        hoyre_motor.run_angle(400, -300, Stop.BRAKE, True)
    else:
        # Kjør frem med konstant hastighet
        venstre_motor.run(200)
        hoyre_motor.run(200)
    
    wait(50)  # Kort pause før neste sjekk

# Stopp motorene
venstre_motor.stop()
hoyre_motor.stop()

# Si "Exercise done" og avslutt
ev3.speaker.say("Exercise done")
ev3.screen.print("Exercise done")

                    </code></pre>
                </article>

                <article class="section-box">
                    <h3>Oppgave 2</h3>
                    <p><a href="EV3Tasks/code/oppgave2.py" download>Last ned filen</a></p>
                    <pre><code>
                      #!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import (Motor, TouchSensor, ColorSensor,
                                 InfraredSensor, UltrasonicSensor, GyroSensor)
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile

# Initialisering
ev3 = EV3Brick()
venstre_motor = Motor(Port.C)
hoyre_motor = Motor(Port.B)
start_stopp_sensor = TouchSensor(Port.S1)
ultralyd_sensor = UltrasonicSensor(Port.S2)

driving = False
ev3.speaker.say("Ready")    

# Hovedløkke
while True:
    # Sjekk knapper
    pressed = ev3.buttons.pressed()
    
    if start_stopp_sensor.pressed(): 
        driving = not driving
        if driving == True:
            ev3.speaker.say("Exercise 2")
        else:
            venstre_motor.stop()
            hoyre_motor.stop()
            ev3.speaker.say("Exercise done")
            break
        
        wait(300)
    
    # Kjør eller stopp
    if driving:
        if ultralyd_sensor.distance() < 300:
            # Hindring oppdaget - stopp umiddelbart
            venstre_motor.stop()
            hoyre_motor.stop()
            wait(100)
            
            # Sving 90 grader til venstre (høyre motor fremover, venstre motor bakover)
            venstre_motor.run_time(-600, 800)  # Venstre motor bakover - økt tid for 90 grader
            hoyre_motor.run_time(600, 800)     # Høyre motor fremover - økt tid for 90 grader
            wait(900)  # Vent til svingen er ferdig
            
            
            # Nå er veien fri - fortsett fremover
            
        else:
            # Kjør rett frem - ingen hindring
            venstre_motor.run(500)
            hoyre_motor.run(500)
    else:
        # Stopp motorene når ikke i kjøremodus
        venstre_motor.stop()
        hoyre_motor.stop()

    
    wait(50)
                    </code></pre>
                </article>

                <article class="section-box">
                    <h3>Oppgave 3</h3>
                    <p><a href="EV3Tasks/code/oppgave3.py" download>Last ned filen</a></p>
                    <pre><code>
                      #!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import (Motor, TouchSensor, ColorSensor,
                                 InfraredSensor, UltrasonicSensor, GyroSensor)
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile
import random
# Initialiser EV3-brikken (hovedenhenten til roboten) 
hjernen = EV3Brick()

# Initialiser motorene på port B og C (venstre og høyre hjul)
venstre_motor = Motor(Port.A)
hoyre_motor = Motor(Port.D)

#kommand for å styre både høyre og venstre motor som 'robot', må ha størrelse og avstand mellom hjul i tilegg.
robot = DriveBase(hoyre_motor, venstre_motor, wheel_diameter=56, axle_track=114)

#sensorene
farge_sensor = ColorSensor(Port.S1)
ultra = UltrasonicSensor(Port.S3)

#definerer 'klokke' for å holde styr på tid 
klokke = StopWatch()

#tilfeldig ting roboten gjør for å 'underholde'
moro = [
    lambda: hjernen.speaker.play_file(SoundFile.HELLO),
    lambda: hjernen.speaker.play_file(SoundFile.HORN_1),
    lambda: hjernen.speaker.play_file(SoundFile.MAGIC_WAND),
    lambda: hjernen.screen.print("Hei der!"),
]

while True:
    # Eksempel på enkel linjefølger
    if farge_sensor.reflection() < 20: # mørkt underlag, dårlig refleksjon/lys 
        venstre_motor.run(200)
        hoyre_motor.run(100)
    else:
        venstre_motor.run(50)
        hoyre_motor.run(300)                                                                     

    #Klokke for å underholde hvert 10 sekund
    if klokke.time() > 10000: # 10 sekunder
        robot.stop()
        random.choice(moro)() # velger en tilfeldig funksjon fra 'moro' listen og kjører den
        wait(1000)
        klokke.reset()

    #Stopper robot da hinderet er nærmere enn 10 cm, og spiller av 'cheering' lyd
    if ultra.distance() < 100:  # 10 cm
        robot.stop()
        hjernen.speaker.play_file(SoundFile.CHEERING)
        wait(1000)
        break

    #funksjon for å stoppe programmet utenom å bruke hinderen (i tilfølge noe går galt)
    if Button.CENTER in hjernen.buttons.pressed():
        break
                    </code></pre>
                </article>

                <article class="section-box">
                    <h3>Oppgave 4</h3>
                    <p><a href="EV3Tasks/code/oppgave4.py" download>Last ned filen</a></p>
                    <pre><code>
                      #!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import (Motor, TouchSensor, ColorSensor,
                                 InfraredSensor, UltrasonicSensor, GyroSensor)
from pybricks.parameters import Port, Stop, Direction, Button, Color
from pybricks.tools import wait, StopWatch, DataLog
from pybricks.robotics import DriveBase
from pybricks.media.ev3dev import SoundFile, ImageFile


 
#Creating our variables
ev3 = EV3Brick()

left_motor = Motor(Port.D)
left_sensor = ColorSensor(Port.S1).color()

right_motor = Motor(Port.D)
right_sensor = ColorSensor(Port.S4).color()
program = True
SPEED = 300
SWING_SPEED = 50

driving_left = False
driving_right = False
came_back = True


#Functions
def Drive(): #This function drives the machine
    global driving_left
    global driving_right

    if left_sensor == Color.BLACK and right_sensor == Color.WHITE: # left sees black, right sees white (too far to the right)
        came_back = False
        driving_left = True
        right_motor.run(SPEED)
        left_motor.run(SWING_SPEED)
        if right_sensor == Color.WHITE and left_sensor == Color.WHITE:
            came_back = True
            driving_left = False
    elif right_sensor == Color.BLACK and left_sensor == Color.WHITE: # right sees black, left sees white (too far to the left)
        came_back = False
        driving_right = True
        right_motor.run(SWING_SPEED)
        left_motor.run(SPEED)
        if right_sensor == Color.WHITE and left_sensor == Color.WHITE:
            came_back = True
            driving_right = False
    elif left_sensor == Color.RED or right_sensor == Color.RED: # if either sensor sees red
        ...
    else: #Then the only other thing that can happen is if the robot is in line, so both sensors see white
        if came_back:
            right_motor.run(SPEED)
            left_motor.run(SPEED)
            ev3.screen.print("Forward")
        else:
            if driving_left:
                ev3.screen.print("You went too far out left")
                ev3.speaker.say("You went too far out left")
            elif driving_right:
                ev3.screen.print("You went too far out right")
                ev3.speaker.say("You went too far out right")
            else:
                ev3.screen.print("Logic error")
                ev3.speaker.say("Logic errort")
            


while program: #while our program is true
    wait(2000) #Waits 2 seconds before starting
    Drive()
                    </code></pre>
                </article>
            </section>
        </div>

        <!-- LEXO ARM TAB -->
        <div id="lexo" class="tab-content">
            <h2>LEXO Arm</h2>
            <section class="section-box">
                <h3>Kode</h3>
                <p><a href="Lexoarm/main.py" download>Last ned main.py</a></p>
                <pre><code>
                  #!/usr/bin/env pybricks-micropython
from pybricks.hubs import EV3Brick
from pybricks.ev3devices import Motor, TouchSensor  # Legger til TouchSensor
from pybricks.parameters import Port, Stop, Button
from pybricks.tools import wait

# Opprett EV3 og motorer
ev3 = EV3Brick()

# Oppretter motorene på port A og B
motor1 = Motor(Port.A)
motor2 = Motor(Port.B)

# Oppretter touchSensorer på port S1 og S2
ned_sensor = TouchSensor(Port.S1)   # Kjør opp / utover
opp_sensor = TouchSensor(Port.S2)   # Kjør ned / innover

# Definerer Hastigheter
RASK = 120    # Hastighet for Konsentrisk (rask innover)
SAKTE = 120   # Hastighet for Eksentrisk (sakte utover)

# Funksjon som stopper begge motorene og holder posisjonen
def stopp():
    motor1.stop(Stop.HOLD)
    motor2.stop(Stop.HOLD)

# Funksjon som kjører motorene innover (negativ hastighet)
def kjor_innover():
    motor1.run(-RASK)
    motor2.run(-RASK) 

# Funksjon som kjører motorene utover (positiv hastighet)
def kjor_utover():
    motor1.run(SAKTE)
    motor2.run(SAKTE)

# Hovedprogram
# Skriver instruksjoner på EV3-skjermen Hovedprogram
ev3.screen.print("Trykk knappen rød for å kjøre inn")
ev3.screen.print("Trykk knappen grønn for å kjøre ut")

# Hovedløkka som kjører kontinuerlig
while True:
    
    # Hvis ned-sensoren trykkes → kjør motorene innover
    if ned_sensor.pressed():
        ev3.screen.print("Kjører INN")
        kjor_innover()

     # Hvis opp-sensoren trykkes → kjør motorene utover
    elif opp_sensor.pressed():
        ev3.screen.print("Kjører UT")
        kjor_utover()
    
    # Hvis ingen sensor trykkes → stopp motorene
    else:
        stopp()

    # Liten pause for å unngå overbelastning av prosessoren
    wait(10)
                </code></pre>
            </section>
            <section class="section-box">
                <h3>Rapport</h3>
                <!-- PDF kan åpnes i ny fane -->
                <p><a href="Lexoarm/Teambasert_endeligVurdering.pdf" target="_blank">Åpne Rapport (PDF)</a></p>
            </section>
            <section class="section-box">
                <h3>Presentasjon</h3>
                <!-- PDF kan åpnes i ny fane -->
                <p><a href="Lexoarm/LEXOARM-Presentasjon.pdf" target="_blank">Åpne Presentasjon (PDF)</a></p>
            </section>
            <section class="section-box">
                <h3>Refleksjon</h3>
                <!-- Word-filer MÅ lastes ned -->
                <p>Word-filer kan ikke vises i nettleseren.</p>
                <p><a href="Lexoarm/refleksjon.pdf" download>Last ned Refleksjon (Word)</a></p>
            </section>
        </div>

        <!-- DATAARKITEKTUR TAB -->
        <div id="data" class="tab-content">
            <h2>Dataarkitektur</h2>
            <section class="section-box">
                <h3>Rapport</h3>
                <p><a href="Dataarkitektur/rapport ssd (1).pdf" target="_blank">Åpne Rapport (PDF)</a></p>
            </section>
            <section class="section-box">
                <h3>PowerPoint</h3>
                <!-- PPTX MÅ lastes ned -->
                <p>PowerPoint-filer kan ikke vises i nettleseren.</p>
                <p><a href="Dataarkitektur/datamaskinArkitektur oppg.pptx" download>Last ned Presentasjon (PPTX)</a></p>
            </section>
        </div>
    </main>

    <footer>
        <p>© 2025 Chris Mulunda Mpinda</p>
    </footer>

    <script>
        const tabs = document.querySelectorAll('.tab');
        const contents = document.querySelectorAll('.tab-content');

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                contents.forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab).classList.add('active');
            });
        });
    </script>

</body>
</html>